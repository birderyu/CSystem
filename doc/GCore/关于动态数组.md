#关于动态数组  
动态数组（GDynamicArray）派生自数组（GArray），是为了模拟分配在堆内存上的数组的一种数据结构，在早期就已经存在。GDynamicArray是一个不可派生的类（final class），其内部存储了一个指向数据首地址的指针，和一个表示数组长度的变量。这么一个看似简单的类，其实内部存在巨大的隐患和风险：  
##数组的创建和销毁  
假设有一个类GTest，这里先假设它包含一个默认的构造函数、一个拷贝构造函数、一个移动构造函数和一个析构函数。我们知道，在C++中，调用下面的语句时，创建一个该类的数组：  
```C++
gsize arr_size = 10;
GTest *arr = new GTest[arr_size];
```  
在这个例子中，数组的创建，其实分为两个过程：第一步是**在堆上分配十个元素的空间**，第二步是**依次调用这十个元素的构造函数**。  
调用下面的语句，销毁这个数组：  
```C++
delete [] arr;
```  
这个数组销毁的过程，其实也分为两步：第一步是**依次调用所有元素的析构函数**，第二步是**释放空间**。  
GDynamicArray的构造和析构也会模拟这一个过程，但若遇到内置类型，或不含有构造函数的类，又需要特殊处理。并且，GDynamicArray的使用频率将会非常频繁。为了保证效率，我将这个判断的过程从运行期提前到编译器，通过**萃取器GTypeTraits**获取当前数组元素的类型信息，根据这一信息处理不同的逻辑。这一部分逻辑被我封装到了基类GArray中。  
##拷贝和移动  
GDynamicArray的拷贝构造将会一定的开销，拷贝的过程与构造相同，都是根据萃取结果的不同处理，这一部分逻辑也在GArray中有所体现，这里主要要说是移动的过程。  
移动操作在GDynamicArray中有两处体现，一是GDynamicArray的移动构造和移动运算符。GDynamicArray的移动构造非常简单：  
```C++
template <typename DataT>
GINLINE GDynamicArray<DataT>::GDynamicArray(GDynamicArray<DataT> &&arr)
: m_pData(arr.m_pData), m_nSize(arr.m_nSize)
{
	arr.m_pData = GNULL;
	arr.m_nSize = 0;
}
```  
可以看出，移动构造的过程就是将待移动数组的指针和数组长度赋值给自己，但要注意移动的后续操作，这里就是将待移动数组给置空。移动运算符的实现与之类似。  
移动操作在GDynamicArray中的另一个体现是元素的移动操作，如改变数组尺寸的方法Resize和移除数组元素的方法RemoveAt，在实现的过程中，我会优先使用移动操作而非拷贝操作。  
##隐含的内存泄漏风险  
这么一个简单的类，其实隐含了很多内存泄漏的风险，都体现在未调用元素的析构函数上。比如在动态数组销毁的时候，如果数组内部存储的是内置类型，其实只需要归还空间即可，但若元素的类型中需要析构函数执行资源的归还操作，就必须依次调用元素的析构函数。  
在移除数组元素的时候，也要调用数组元素的析构函数，保证内存不会泄漏。  