#关于范型  
与Java的模板不同，C++的模板可以实现真正高效的范型编程。C++的范型发生在编译时，而非运行时，是静态绑定，在一定程度上能够取代动态绑定，一定程度上减少运行开销。但范型也会造成代码的膨胀，增加编译成本。在实际编程工作中，范型多用于基础库(library)的编写之中，最典型也最能体现C++范型编程长处的例子就是STL。在业务系统之中，相关的工作往往被多态替代。  
在GNova中也大量使用了范型编程，总结起来，共有以下几个方面：  
## 仿函数（Functor）  
仿函数也称函数对象，从实现上看其实是一种重载了括号运算符的类，在使用中这些类的对象可以模仿出函数的调用方式。仿函数用以替代函数指针，在GNova中被大量使用。提供了若干常用的仿函数类，这些类的命名以F结尾，位于文件gfunctor.h中。  
##萃取器(Traits)  
萃取器是一种元编程技术，其目的是获取对象的类型、修饰符等元信息。使用范型实现的萃取器，能够在程序编译期间推断出对象的元信息。这些类位于文件gtraits.h中。  
##奇异递归模板（Curiously Recurring Template Pattern，CRTP）  
CRTP是一种模板使用的技巧，其特点是模板的参数是当前类本身。使用CRTP而非一个普通的类作为基类，可以令每一个子类都拥有一份基类的拷贝。  